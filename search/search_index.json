{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Pcsx-redux emulator documentation. You can get the emulator for various platforms here : https://github.com/grumpycoders/pcsx-redux#where You can find a one page version of this site here : One page version Compiling Pcsx-redux Menus Command line arguments GDB server Internal MIPS api Web Server OpenBios CPU trace dump","title":"Home"},{"location":"CPU_trace_dump/","text":"Dumping a CPU trace to a file Setup In pcsx-redux, make sure Debug > Show logs is enabled. In the 'Logs' window, hide all logs : Displayed > Hide all To avoid unnecessary noise, you can also skip ISR during CPU traces : Special > Skip ISR during CPU traces Begin dump To dump the CPU traces, launch pcsx-redux with the following command : 1 2 3 pcsx-redux -stdout -logfile log.txt # Alternatively, you can use -stdout on its own and pipe the output to a file. pcsx-redux -stdout >> log.txt You can use additional flags to launch an executable/disk image in one go, e.g : 1 pcsx-redux -stdout -logfile tst.log -iso image.cue -run Source https://discord.com/channels/642647820683444236/663664210525290507/882608398993063997","title":"Dumping a CPU trace to a file"},{"location":"CPU_trace_dump/#dumping-a-cpu-trace-to-a-file","text":"","title":"Dumping a CPU trace to a file"},{"location":"CPU_trace_dump/#setup","text":"In pcsx-redux, make sure Debug > Show logs is enabled. In the 'Logs' window, hide all logs : Displayed > Hide all To avoid unnecessary noise, you can also skip ISR during CPU traces : Special > Skip ISR during CPU traces","title":"Setup"},{"location":"CPU_trace_dump/#begin-dump","text":"To dump the CPU traces, launch pcsx-redux with the following command : 1 2 3 pcsx-redux -stdout -logfile log.txt # Alternatively, you can use -stdout on its own and pipe the output to a file. pcsx-redux -stdout >> log.txt You can use additional flags to launch an executable/disk image in one go, e.g : 1 pcsx-redux -stdout -logfile tst.log -iso image.cue -run","title":"Begin dump"},{"location":"CPU_trace_dump/#source","text":"https://discord.com/channels/642647820683444236/663664210525290507/882608398993063997","title":"Source"},{"location":"cli_flags/","text":"Command Line Flags You can launch pcsx-redux with the following command line parameters: The parsing code doesn't care about the number of dashes in the parameter's flag, so '-' can be used as well as '--', or any number of dashes. Flag Meaning -run Begin execution on startup. -stdout Redirect log output to stdout. -logfile Specify a file to log output to. -bios Specify a BIOS file. -testmode Interpret internal API 's pcsx_exit() command and close the emulator. -loadexe Load a PSX exe. -iso Load a PSX disk image (iso, bin/cue). -memcard1 Specify a memory card file to use as memory card slot 1. -memcard2 Specify a memory card file to use as memory card slot 2. -pcdrv Enable the pcdrv: device interface. (Access PC filesystem through SIO) -pcdrvbase Specify base directory for pcdrv","title":"Command Line Flags"},{"location":"cli_flags/#command-line-flags","text":"You can launch pcsx-redux with the following command line parameters: The parsing code doesn't care about the number of dashes in the parameter's flag, so '-' can be used as well as '--', or any number of dashes. Flag Meaning -run Begin execution on startup. -stdout Redirect log output to stdout. -logfile Specify a file to log output to. -bios Specify a BIOS file. -testmode Interpret internal API 's pcsx_exit() command and close the emulator. -loadexe Load a PSX exe. -iso Load a PSX disk image (iso, bin/cue). -memcard1 Specify a memory card file to use as memory card slot 1. -memcard2 Specify a memory card file to use as memory card slot 2. -pcdrv Enable the pcdrv: device interface. (Access PC filesystem through SIO) -pcdrvbase Specify base directory for pcdrv","title":"Command Line Flags"},{"location":"compiling/","text":"Compiling Pcsx-redux Getting the sources The only location for the source is on github . Clone recursively, as the project uses submodules: git clone https://github.com/grumpycoders/pcsx-redux.git --recursive . Windows Install Visual Studio 2019 Community Edition . Open the file vsprojects\\pcsx-redux.sln , select pcsx-redux -> pcsx-redux , right click, Set as Startup Project , and hit F7 to build. The project follows the open-and-build paradigm with no extra step, so no specific dependency ought to be needed, as NuGet will take care of downloading them automatically for you on the first build. Note: If you get an error saying hresult e_fail has been returned from a call to a com component , you might need to delete the .suo file in vsproject/vs, restart Visual Studio and retry. Openbios Using Visual Studio Code , one can use the task \"make_openbios\" to compile: CTRL-P then task make_openbios to compile. Linux Compiling with Docker Run ./dockermake.sh . You need docker for this to work. 1 2 3 4 # Debian derivative; Ubuntu, Mint... sudo apt install docker # Arch derivative; Manjaro... sudo pacman -S docker You will also need a few libraries on your system for this to work. Check the Dockerfile for a list of library packages to install. Compiling with make Debian derivatives ( for full emulator compilation ): 1 sudo apt-get install -y build-essential git make pkg-config clang g++ g++-mipsel-linux-gnu cpp-mipsel-linux-gnu binutils-mipsel-linux-gnu libfreetype-dev libavcodec-dev libavformat-dev libavutil-dev libglfw3-dev libswresample-dev libuv1-dev zlib1g-dev Arch derivatives : 1 sudo pacman -S clang git make pkg-config ffmpeg libuv zlib glfw-x11 curl xorg-server-xvfb You can then just enter the 'pcsx-redux' directory and compile without using docker with make . If you have a different mips compiler, you'll need to override some variables, such as PREFIX=mipsel-none-elf FORMAT=elf32-littlemips . Openbios Building OpenBIOS on Linux can be done with docker : ./dockermake.sh openbios , or using make , with the g++-mipsel-linux-gnu package installed ; make openbios . MacOS You need MacOS Catalina with the latest XCode to build, as well as a few homebrew packages. Run the brew installation script to get all the necessary dependencies. Run make to build. Compiling OpenBIOS will require a mips compiler, that you can generate using the following commands: Openbios 1 2 brew install ./tools/macos-mips/mipsel-none-elf-binutils.rb brew install ./tools/macos-mips/mipsel-none-elf-gcc.rb Then, you can compile OpenBIOS using make -C ./src/mips/openbios . Compiling PSX code If you're only interested in compiling psx code, you can clone the pcsx-redux repo; 1 git clone https://github.com/grumpycoders/pcsx-redux.git --recursive then install a mips toolchain and get the converted PsyQ libraries in the pcsx-redux/src/mips/psyq/ folder as per these instructions . You can also find the pre-compiled converted Psyq libraries online . Getting the toolchain on Windows Download the MIPS toolchain here : https://static.grumpycoder.net/pixel/mips/g++-mipsel-none-elf-10.3.0.zip and add the bin folder to your $PATH . You can test it's working by launching a command prompt and typing mipsel-none-elf-gcc.exe --version . If you get a message like mipsel-none-gnu-gcc (GCC) 10.3.0 , then it's working ! Getting the toolchain on GNU/Linux Debian derivative; Ubuntu, Mint... 1 sudo apt install g++-mipsel-linux-gnu cpp-mipsel-linux-gnu binutils-mipsel-linux-gnu Arch derivative; Manjaro... The mipsel environment can be installed from AUR : cross-mipsel-linux-gnu-binutils and cross-mipsel-linux-gnu-gcc using your AURhelper of choice: 1 trizen -S cross-mipsel-linux-gnu-binutils cross-mipsel-linux-gnu-gcc","title":"Compiling Pcsx-redux"},{"location":"compiling/#compiling-pcsx-redux","text":"","title":"Compiling Pcsx-redux"},{"location":"compiling/#getting-the-sources","text":"The only location for the source is on github . Clone recursively, as the project uses submodules: git clone https://github.com/grumpycoders/pcsx-redux.git --recursive .","title":"Getting the sources"},{"location":"compiling/#windows","text":"Install Visual Studio 2019 Community Edition . Open the file vsprojects\\pcsx-redux.sln , select pcsx-redux -> pcsx-redux , right click, Set as Startup Project , and hit F7 to build. The project follows the open-and-build paradigm with no extra step, so no specific dependency ought to be needed, as NuGet will take care of downloading them automatically for you on the first build. Note: If you get an error saying hresult e_fail has been returned from a call to a com component , you might need to delete the .suo file in vsproject/vs, restart Visual Studio and retry.","title":"Windows"},{"location":"compiling/#openbios","text":"Using Visual Studio Code , one can use the task \"make_openbios\" to compile: CTRL-P then task make_openbios to compile.","title":"Openbios"},{"location":"compiling/#linux","text":"","title":"Linux"},{"location":"compiling/#compiling-with-docker","text":"Run ./dockermake.sh . You need docker for this to work. 1 2 3 4 # Debian derivative; Ubuntu, Mint... sudo apt install docker # Arch derivative; Manjaro... sudo pacman -S docker You will also need a few libraries on your system for this to work. Check the Dockerfile for a list of library packages to install.","title":"Compiling with Docker"},{"location":"compiling/#compiling-with-make","text":"Debian derivatives ( for full emulator compilation ): 1 sudo apt-get install -y build-essential git make pkg-config clang g++ g++-mipsel-linux-gnu cpp-mipsel-linux-gnu binutils-mipsel-linux-gnu libfreetype-dev libavcodec-dev libavformat-dev libavutil-dev libglfw3-dev libswresample-dev libuv1-dev zlib1g-dev Arch derivatives : 1 sudo pacman -S clang git make pkg-config ffmpeg libuv zlib glfw-x11 curl xorg-server-xvfb You can then just enter the 'pcsx-redux' directory and compile without using docker with make . If you have a different mips compiler, you'll need to override some variables, such as PREFIX=mipsel-none-elf FORMAT=elf32-littlemips .","title":"Compiling with make"},{"location":"compiling/#openbios_1","text":"Building OpenBIOS on Linux can be done with docker : ./dockermake.sh openbios , or using make , with the g++-mipsel-linux-gnu package installed ; make openbios .","title":"Openbios"},{"location":"compiling/#macos","text":"You need MacOS Catalina with the latest XCode to build, as well as a few homebrew packages. Run the brew installation script to get all the necessary dependencies. Run make to build. Compiling OpenBIOS will require a mips compiler, that you can generate using the following commands:","title":"MacOS"},{"location":"compiling/#openbios_2","text":"1 2 brew install ./tools/macos-mips/mipsel-none-elf-binutils.rb brew install ./tools/macos-mips/mipsel-none-elf-gcc.rb Then, you can compile OpenBIOS using make -C ./src/mips/openbios .","title":"Openbios"},{"location":"compiling/#compiling-psx-code","text":"If you're only interested in compiling psx code, you can clone the pcsx-redux repo; 1 git clone https://github.com/grumpycoders/pcsx-redux.git --recursive then install a mips toolchain and get the converted PsyQ libraries in the pcsx-redux/src/mips/psyq/ folder as per these instructions . You can also find the pre-compiled converted Psyq libraries online .","title":"Compiling PSX code"},{"location":"compiling/#getting-the-toolchain-on-windows","text":"Download the MIPS toolchain here : https://static.grumpycoder.net/pixel/mips/g++-mipsel-none-elf-10.3.0.zip and add the bin folder to your $PATH . You can test it's working by launching a command prompt and typing mipsel-none-elf-gcc.exe --version . If you get a message like mipsel-none-gnu-gcc (GCC) 10.3.0 , then it's working !","title":"Getting the toolchain on Windows"},{"location":"compiling/#getting-the-toolchain-on-gnulinux","text":"","title":"Getting the toolchain on GNU/Linux"},{"location":"compiling/#debian-derivative-ubuntu-mint","text":"1 sudo apt install g++-mipsel-linux-gnu cpp-mipsel-linux-gnu binutils-mipsel-linux-gnu","title":"Debian derivative; Ubuntu, Mint..."},{"location":"compiling/#arch-derivative-manjaro","text":"The mipsel environment can be installed from AUR : cross-mipsel-linux-gnu-binutils and cross-mipsel-linux-gnu-gcc using your AURhelper of choice: 1 trizen -S cross-mipsel-linux-gnu-binutils cross-mipsel-linux-gnu-gcc","title":"Arch derivative; Manjaro..."},{"location":"gdb-server/","text":"GDB server The GDB server allows you to set breakpoints and control your PSX program's execution from your gdb compatible IDE. Enabling the GDB server In pcsx-redux: Configuration > Emulation > Enable GDB server . Make sure the debugger is also enabled. GDB setup You need gdb-multiarch on your system : Windows Download a pre-compiled version from here : https://static.grumpycoder.net/pixel/gdb-multiarch-windows/ GNU/Linux Install via your package manager : 1 2 3 4 5 # Debian derivative; Ubuntu, Mint... sudo apt install gdb-multiarch # Arch derivative; Manjaro # 'gdb-multiarch' is available in aur : https://aur.archlinux.org/packages/gdb-multiarch/ sudo trizen -S gdb-multiarch IDE setup MS VScode Install the Native debug extension : https://marketplace.visualstudio.com/items?itemName=webfreak.debug Adapt your launch.json file to your environment : A sample lanuch.json file is available here . This should go in your-project/.vscode/ . You need to adapt the values of \"target\" , \"gdbpath\" and \"autorun\" according to your system : target This is the path to your .elf executable : 1 \"target\" : \"HelloWorld.elf\" , https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L9 gdbpath This the path to the gdb-multiarch executable: 1 \"gdbpath\" : \"/usr/bin/gdb-multiarch\" , https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L10 autorun 1 2 3 4 \"autorun\" : [ \"target remote localhost:3333\" , [ ... ] \"load HelloWorld.elf\" , Make sure that \"load your-file.elf\" corresponds to the \"target\" value. https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L15 By default, using localhost should work, but if encountering trouble, try using your computer's local IP (e.g; 192.168.x.x, 10.0.x.x, etc.) https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L13 Geany Make sure you installed the official plugins and enable the Scope debugger . To enable the plugin, open Geany, go to Tools > Plugin manager and enable Scope Debugger . You can find the debugging facilities in the Debug menu ; You can find the plugin's documentation here : https://plugins.geany.org/scope.html .gdbinit Create a .gdbinit file at the root of your project with the following content, adapting the path to your elf file and the gdb server's ip. 1 2 3 4 target remote localhost:3333 symbol-file load /path/to/your/executable.elf monitor reset shellhalt load /path/to/your/executable.elf Plugin configuration In Geany : Debug > Setup Program : Beginning Debugging Launch pcsx-redux , then run the debugger from your IDE. It should load the elf file, and execute until the next breakpoint. Starting debugging in Geany Your browser does not support the video tag. Source : https://archive.org/details/pcsx_redux_geany_gdb Additional tools https://github.com/cyrus-and/gdb-dashboard/","title":"GDB server"},{"location":"gdb-server/#gdb-server","text":"The GDB server allows you to set breakpoints and control your PSX program's execution from your gdb compatible IDE.","title":"GDB server"},{"location":"gdb-server/#enabling-the-gdb-server","text":"In pcsx-redux: Configuration > Emulation > Enable GDB server . Make sure the debugger is also enabled.","title":"Enabling the GDB server"},{"location":"gdb-server/#gdb-setup","text":"You need gdb-multiarch on your system :","title":"GDB setup"},{"location":"gdb-server/#windows","text":"Download a pre-compiled version from here : https://static.grumpycoder.net/pixel/gdb-multiarch-windows/","title":"Windows"},{"location":"gdb-server/#gnulinux","text":"Install via your package manager : 1 2 3 4 5 # Debian derivative; Ubuntu, Mint... sudo apt install gdb-multiarch # Arch derivative; Manjaro # 'gdb-multiarch' is available in aur : https://aur.archlinux.org/packages/gdb-multiarch/ sudo trizen -S gdb-multiarch","title":"GNU/Linux"},{"location":"gdb-server/#ide-setup","text":"","title":"IDE setup"},{"location":"gdb-server/#ms-vscode","text":"Install the Native debug extension : https://marketplace.visualstudio.com/items?itemName=webfreak.debug Adapt your launch.json file to your environment : A sample lanuch.json file is available here . This should go in your-project/.vscode/ . You need to adapt the values of \"target\" , \"gdbpath\" and \"autorun\" according to your system :","title":"MS VScode"},{"location":"gdb-server/#target","text":"This is the path to your .elf executable : 1 \"target\" : \"HelloWorld.elf\" , https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L9","title":"target"},{"location":"gdb-server/#gdbpath","text":"This the path to the gdb-multiarch executable: 1 \"gdbpath\" : \"/usr/bin/gdb-multiarch\" , https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L10","title":"gdbpath"},{"location":"gdb-server/#autorun","text":"1 2 3 4 \"autorun\" : [ \"target remote localhost:3333\" , [ ... ] \"load HelloWorld.elf\" , Make sure that \"load your-file.elf\" corresponds to the \"target\" value. https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L15 By default, using localhost should work, but if encountering trouble, try using your computer's local IP (e.g; 192.168.x.x, 10.0.x.x, etc.) https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L13","title":"autorun"},{"location":"gdb-server/#geany","text":"Make sure you installed the official plugins and enable the Scope debugger . To enable the plugin, open Geany, go to Tools > Plugin manager and enable Scope Debugger . You can find the debugging facilities in the Debug menu ; You can find the plugin's documentation here : https://plugins.geany.org/scope.html","title":"Geany"},{"location":"gdb-server/#gdbinit","text":"Create a .gdbinit file at the root of your project with the following content, adapting the path to your elf file and the gdb server's ip. 1 2 3 4 target remote localhost:3333 symbol-file load /path/to/your/executable.elf monitor reset shellhalt load /path/to/your/executable.elf","title":".gdbinit"},{"location":"gdb-server/#plugin-configuration","text":"In Geany : Debug > Setup Program :","title":"Plugin configuration"},{"location":"gdb-server/#beginning-debugging","text":"Launch pcsx-redux , then run the debugger from your IDE. It should load the elf file, and execute until the next breakpoint.","title":"Beginning Debugging"},{"location":"gdb-server/#starting-debugging-in-geany","text":"Your browser does not support the video tag. Source : https://archive.org/details/pcsx_redux_geany_gdb","title":"Starting debugging in Geany"},{"location":"gdb-server/#additional-tools","text":"https://github.com/cyrus-and/gdb-dashboard/","title":"Additional tools"},{"location":"menus/","text":"Pcsx-redux menus The menu bar holds some informations : CPU mode Game ID ImGui FPS counter (not psx internal fps) File Open ISO Close ISO Load Binary Dump save state proto schema Save state slots Load state slots Save global state Load global state Open Lid : Simulate open lid Close Lid : Simulate closed lid Open and Close Lid : Simulate open then closed lid MC1 inserted MC2 inserted Reboot : Restart emulator Quit Emulation Start : Start execution Pause : Pause execution Soft reset : Calls Redux's CPU reset function, which jumps to the BIOS entrypoint (0xBFC00000), resets some COP0 registers and the general purpose registers, and resets some IO. Does not clear vram. Hard reset : Similar to a reboot of the PSX. Configuration Emulation : Emulation settings GPU : graphical processor settings SPU : Sound processor settings UI : Change interface settings Controls : Edit KB/Pad controls Shader presets : Apply a shader preset Configure shaders : show shader editor Debug Help Show Imgui demo About","title":"Pcsx-redux menus"},{"location":"menus/#pcsx-redux-menus","text":"The menu bar holds some informations : CPU mode Game ID ImGui FPS counter (not psx internal fps)","title":"Pcsx-redux menus"},{"location":"menus/#file","text":"Open ISO Close ISO Load Binary Dump save state proto schema Save state slots Load state slots Save global state Load global state Open Lid : Simulate open lid Close Lid : Simulate closed lid Open and Close Lid : Simulate open then closed lid MC1 inserted MC2 inserted Reboot : Restart emulator Quit","title":"File"},{"location":"menus/#emulation","text":"Start : Start execution Pause : Pause execution Soft reset : Calls Redux's CPU reset function, which jumps to the BIOS entrypoint (0xBFC00000), resets some COP0 registers and the general purpose registers, and resets some IO. Does not clear vram. Hard reset : Similar to a reboot of the PSX.","title":"Emulation"},{"location":"menus/#configuration","text":"Emulation : Emulation settings GPU : graphical processor settings SPU : Sound processor settings UI : Change interface settings Controls : Edit KB/Pad controls Shader presets : Apply a shader preset Configure shaders : show shader editor","title":"Configuration"},{"location":"menus/#debug","text":"","title":"Debug"},{"location":"menus/#help","text":"Show Imgui demo About","title":"Help"},{"location":"mips_api/","text":"Mips API Description Pcsx-redux has a special API that mips binaries can use : 1 2 3 4 5 6 static __inline__ void pcsx_putc ( int c ) { * (( volatile char * const ) 0x1f802080 ) = c ; } static __inline__ void pcsx_debugbreak () { * (( volatile char * const ) 0x1f802081 ) = 0 ; } static __inline__ void pcsx_exit ( int code ) { * (( volatile int16_t * const ) 0x1f802082 ) = code ; } static __inline__ void pcsx_message ( const char * msg ) { * (( volatile char * const ) 0x1f802084 ) = msg ; } static __inline__ int pcsx_present () { return * (( volatile uint32_t * const ) 0x1f802080 ) == 0x58534350 ; } Source : https://github.com/grumpycoders/pcsx-redux/blob/main/src/mips/common/hardware/pcsxhw.h#L31-L36 The API needs DEV8/EXP2 (1f802000 to 1f80207f), which holds the hardware register for the bios POST status, to be expanded to 1f8020ff. Thus the need to use a custom crt0.s if you plan on running your code on real hardware. The default file provided with the Nugget+PsyQ development environment does that: 1 2 3 4 5 6 7 8 9 10 11 _start: lw $ t2 , SBUS_DEV8_CTRL lui $ t0 , 8 lui $ t1 , 1 _check_dev8: bge $ t2 , $ t0 , _store_dev8 nop b _check_dev8 add $ t2 , $ t1 _store_dev8: sw $ t2 , SBUS_DEV8_CTRL Source : https://github.com/grumpycoders/pcsx-redux/blob/main/src/mips/common/crt0/crt0.s#L36-L46 Functions The following functions are available : Function Usage pcsx_putc(int c) Print ASCII character with code c to console/stdout. pcsx_debugbreak() Break execution ( Pause emulation ). pcsx_exit(int code) Exit emulator and forward code as exit code. pcsx_message(const char* msg) Create a UI dialog displaying msg pcsx_present() Returns 1 if code is running in pcsx-redux Example of a UI dialog created with pcsx_message() :","title":"Mips API"},{"location":"mips_api/#mips-api","text":"","title":"Mips API"},{"location":"mips_api/#description","text":"Pcsx-redux has a special API that mips binaries can use : 1 2 3 4 5 6 static __inline__ void pcsx_putc ( int c ) { * (( volatile char * const ) 0x1f802080 ) = c ; } static __inline__ void pcsx_debugbreak () { * (( volatile char * const ) 0x1f802081 ) = 0 ; } static __inline__ void pcsx_exit ( int code ) { * (( volatile int16_t * const ) 0x1f802082 ) = code ; } static __inline__ void pcsx_message ( const char * msg ) { * (( volatile char * const ) 0x1f802084 ) = msg ; } static __inline__ int pcsx_present () { return * (( volatile uint32_t * const ) 0x1f802080 ) == 0x58534350 ; } Source : https://github.com/grumpycoders/pcsx-redux/blob/main/src/mips/common/hardware/pcsxhw.h#L31-L36 The API needs DEV8/EXP2 (1f802000 to 1f80207f), which holds the hardware register for the bios POST status, to be expanded to 1f8020ff. Thus the need to use a custom crt0.s if you plan on running your code on real hardware. The default file provided with the Nugget+PsyQ development environment does that: 1 2 3 4 5 6 7 8 9 10 11 _start: lw $ t2 , SBUS_DEV8_CTRL lui $ t0 , 8 lui $ t1 , 1 _check_dev8: bge $ t2 , $ t0 , _store_dev8 nop b _check_dev8 add $ t2 , $ t1 _store_dev8: sw $ t2 , SBUS_DEV8_CTRL Source : https://github.com/grumpycoders/pcsx-redux/blob/main/src/mips/common/crt0/crt0.s#L36-L46","title":"Description"},{"location":"mips_api/#functions","text":"The following functions are available : Function Usage pcsx_putc(int c) Print ASCII character with code c to console/stdout. pcsx_debugbreak() Break execution ( Pause emulation ). pcsx_exit(int code) Exit emulator and forward code as exit code. pcsx_message(const char* msg) Create a UI dialog displaying msg pcsx_present() Returns 1 if code is running in pcsx-redux Example of a UI dialog created with pcsx_message() :","title":"Functions"},{"location":"one/","text":"Menus Pcsx-redux menus The menu bar holds some informations : CPU mode Game ID ImGui FPS counter (not psx internal fps) File Open ISO Close ISO Load Binary Dump save state proto schema Save state slots Load state slots Save global state Load global state Open Lid : Simulate open lid Close Lid : Simulate closed lid Open and Close Lid : Simulate open then closed lid MC1 inserted MC2 inserted Reboot : Restart emulator Quit Emulation Start : Start execution Pause : Pause execution Soft reset : Calls Redux's CPU reset function, which jumps to the BIOS entrypoint (0xBFC00000), resets some COP0 registers and the general purpose registers, and resets some IO. Does not clear vram. Hard reset : Similar to a reboot of the PSX. Configuration Emulation : Emulation settings GPU : graphical processor settings SPU : Sound processor settings UI : Change interface settings Controls : Edit KB/Pad controls Shader presets : Apply a shader preset Configure shaders : show shader editor Debug Help Show Imgui demo About Compiling Compiling Pcsx-redux Getting the sources The only location for the source is on github . Clone recursively, as the project uses submodules: git clone https://github.com/grumpycoders/pcsx-redux.git --recursive . Windows Install Visual Studio 2019 Community Edition . Open the file vsprojects\\pcsx-redux.sln , select pcsx-redux -> pcsx-redux , right click, Set as Startup Project , and hit F7 to build. The project follows the open-and-build paradigm with no extra step, so no specific dependency ought to be needed, as NuGet will take care of downloading them automatically for you on the first build. Note: If you get an error saying hresult e_fail has been returned from a call to a com component , you might need to delete the .suo file in vsproject/vs, restart Visual Studio and retry. Openbios Using Visual Studio Code , one can use the task \"make_openbios\" to compile: CTRL-P then task make_openbios to compile. Linux Compiling with Docker Run ./dockermake.sh . You need docker for this to work. 1 2 3 4 # Debian derivative; Ubuntu, Mint... sudo apt install docker # Arch derivative; Manjaro... sudo pacman -S docker You will also need a few libraries on your system for this to work. Check the Dockerfile for a list of library packages to install. Compiling with make Debian derivatives ( for full emulator compilation ): 1 sudo apt-get install -y build-essential git make pkg-config clang g++ g++-mipsel-linux-gnu cpp-mipsel-linux-gnu binutils-mipsel-linux-gnu libfreetype-dev libavcodec-dev libavformat-dev libavutil-dev libglfw3-dev libswresample-dev libuv1-dev zlib1g-dev Arch derivatives : 1 sudo pacman -S clang git make pkg-config ffmpeg libuv zlib glfw-x11 curl xorg-server-xvfb You can then just enter the 'pcsx-redux' directory and compile without using docker with make . If you have a different mips compiler, you'll need to override some variables, such as PREFIX=mipsel-none-elf FORMAT=elf32-littlemips . Openbios Building OpenBIOS on Linux can be done with docker : ./dockermake.sh openbios , or using make , with the g++-mipsel-linux-gnu package installed ; make openbios . MacOS You need MacOS Catalina with the latest XCode to build, as well as a few homebrew packages. Run the brew installation script to get all the necessary dependencies. Run make to build. Compiling OpenBIOS will require a mips compiler, that you can generate using the following commands: Openbios 1 2 brew install ./tools/macos-mips/mipsel-none-elf-binutils.rb brew install ./tools/macos-mips/mipsel-none-elf-gcc.rb Then, you can compile OpenBIOS using make -C ./src/mips/openbios . Compiling PSX code If you're only interested in compiling psx code, you can clone the pcsx-redux repo; 1 git clone https://github.com/grumpycoders/pcsx-redux.git --recursive then install a mips toolchain and get the converted PsyQ libraries in the pcsx-redux/src/mips/psyq/ folder as per these instructions . You can also find the pre-compiled converted Psyq libraries online . Getting the toolchain on Windows Download the MIPS toolchain here : https://static.grumpycoder.net/pixel/mips/g++-mipsel-none-elf-10.3.0.zip and add the bin folder to your $PATH . You can test it's working by launching a command prompt and typing mipsel-none-elf-gcc.exe --version . If you get a message like mipsel-none-gnu-gcc (GCC) 10.3.0 , then it's working ! Getting the toolchain on GNU/Linux Debian derivative; Ubuntu, Mint... 1 sudo apt install g++-mipsel-linux-gnu cpp-mipsel-linux-gnu binutils-mipsel-linux-gnu Arch derivative; Manjaro... The mipsel environment can be installed from AUR : cross-mipsel-linux-gnu-binutils and cross-mipsel-linux-gnu-gcc using your AURhelper of choice: 1 trizen -S cross-mipsel-linux-gnu-binutils cross-mipsel-linux-gnu-gcc Cli & flags Command Line Flags You can launch pcsx-redux with the following command line parameters: The parsing code doesn't care about the number of dashes in the parameter's flag, so '-' can be used as well as '--', or any number of dashes. Flag Meaning -run Begin execution on startup. -stdout Redirect log output to stdout. -logfile Specify a file to log output to. -bios Specify a BIOS file. -testmode Interpret internal API 's pcsx_exit() command and close the emulator. -loadexe Load a PSX exe. -iso Load a PSX disk image (iso, bin/cue). -memcard1 Specify a memory card file to use as memory card slot 1. -memcard2 Specify a memory card file to use as memory card slot 2. -pcdrv Enable the pcdrv: device interface. (Access PC filesystem through SIO) -pcdrvbase Specify base directory for pcdrv Gdb-server GDB server The GDB server allows you to set breakpoints and control your PSX program's execution from your gdb compatible IDE. Enabling the GDB server In pcsx-redux: Configuration > Emulation > Enable GDB server . Make sure the debugger is also enabled. GDB setup You need gdb-multiarch on your system : Windows Download a pre-compiled version from here : https://static.grumpycoder.net/pixel/gdb-multiarch-windows/ GNU/Linux Install via your package manager : 1 2 3 4 5 # Debian derivative; Ubuntu, Mint... sudo apt install gdb-multiarch # Arch derivative; Manjaro # 'gdb-multiarch' is available in aur : https://aur.archlinux.org/packages/gdb-multiarch/ sudo trizen -S gdb-multiarch IDE setup MS VScode Install the Native debug extension : https://marketplace.visualstudio.com/items?itemName=webfreak.debug Adapt your launch.json file to your environment : A sample lanuch.json file is available here . This should go in your-project/.vscode/ . You need to adapt the values of \"target\" , \"gdbpath\" and \"autorun\" according to your system : target This is the path to your .elf executable : 1 \"target\" : \"HelloWorld.elf\" , https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L9 gdbpath This the path to the gdb-multiarch executable: 1 \"gdbpath\" : \"/usr/bin/gdb-multiarch\" , https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L10 autorun 1 2 3 4 \"autorun\" : [ \"target remote localhost:3333\" , [ ... ] \"load HelloWorld.elf\" , Make sure that \"load your-file.elf\" corresponds to the \"target\" value. https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L15 By default, using localhost should work, but if encountering trouble, try using your computer's local IP (e.g; 192.168.x.x, 10.0.x.x, etc.) https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L13 Geany Make sure you installed the official plugins and enable the Scope debugger . To enable the plugin, open Geany, go to Tools > Plugin manager and enable Scope Debugger . You can find the debugging facilities in the Debug menu ; You can find the plugin's documentation here : https://plugins.geany.org/scope.html .gdbinit Create a .gdbinit file at the root of your project with the following content, adapting the path to your elf file and the gdb server's ip. 1 2 3 4 target remote localhost:3333 symbol-file load /path/to/your/executable.elf monitor reset shellhalt load /path/to/your/executable.elf Plugin configuration In Geany : Debug > Setup Program : Beginning Debugging Launch pcsx-redux , then run the debugger from your IDE. It should load the elf file, and execute until the next breakpoint. Starting debugging in Geany Your browser does not support the video tag. Source : https://archive.org/details/pcsx_redux_geany_gdb Additional tools https://github.com/cyrus-and/gdb-dashboard/ Mips & api Mips API Description Pcsx-redux has a special API that mips binaries can use : 1 2 3 4 5 6 static __inline__ void pcsx_putc ( int c ) { * (( volatile char * const ) 0x1f802080 ) = c ; } static __inline__ void pcsx_debugbreak () { * (( volatile char * const ) 0x1f802081 ) = 0 ; } static __inline__ void pcsx_exit ( int code ) { * (( volatile int16_t * const ) 0x1f802082 ) = code ; } static __inline__ void pcsx_message ( const char * msg ) { * (( volatile char * const ) 0x1f802084 ) = msg ; } static __inline__ int pcsx_present () { return * (( volatile uint32_t * const ) 0x1f802080 ) == 0x58534350 ; } Source : https://github.com/grumpycoders/pcsx-redux/blob/main/src/mips/common/hardware/pcsxhw.h#L31-L36 The API needs DEV8/EXP2 (1f802000 to 1f80207f), which holds the hardware register for the bios POST status, to be expanded to 1f8020ff. Thus the need to use a custom crt0.s if you plan on running your code on real hardware. The default file provided with the Nugget+PsyQ development environment does that: 1 2 3 4 5 6 7 8 9 10 11 _start: lw $ t2 , SBUS_DEV8_CTRL lui $ t0 , 8 lui $ t1 , 1 _check_dev8: bge $ t2 , $ t0 , _store_dev8 nop b _check_dev8 add $ t2 , $ t1 _store_dev8: sw $ t2 , SBUS_DEV8_CTRL Source : https://github.com/grumpycoders/pcsx-redux/blob/main/src/mips/common/crt0/crt0.s#L36-L46 Functions The following functions are available : Function Usage pcsx_putc(int c) Print ASCII character with code c to console/stdout. pcsx_debugbreak() Break execution ( Pause emulation ). pcsx_exit(int code) Exit emulator and forward code as exit code. pcsx_message(const char* msg) Create a UI dialog displaying msg pcsx_present() Returns 1 if code is running in pcsx-redux Example of a UI dialog created with pcsx_message() : Cpu, trace & dump Dumping a CPU trace to a file Setup In pcsx-redux, make sure Debug > Show logs is enabled. In the 'Logs' window, hide all logs : Displayed > Hide all To avoid unnecessary noise, you can also skip ISR during CPU traces : Special > Skip ISR during CPU traces Begin dump To dump the CPU traces, launch pcsx-redux with the following command : 1 2 3 pcsx-redux -stdout -logfile log.txt # Alternatively, you can use -stdout on its own and pipe the output to a file. pcsx-redux -stdout >> log.txt You can use additional flags to launch an executable/disk image in one go, e.g : 1 pcsx-redux -stdout -logfile tst.log -iso image.cue -run Source https://discord.com/channels/642647820683444236/663664210525290507/882608398993063997 Web & server Web server A web server can be activated. This allows the use of a REST api to access various features. Activation You can activate the web server by going to Configuration > Emulation > Enable Web Server REST API By default, the server listens for incoming connection on localhost:8080 . URL Function http://localhost:8080/api/v1/gpu/vram/raw Dump VRAM http://localhost:8080/api/v1/cpu/ram/raw Dump RAM Openbios Openbios Openbios is, as it's name imply, an open-source alternative to a retail PSX bios that can be non-trivial to dump. Purposes of Openbios Educational Ease of distribution Automated testing See this page for more details. Building It is compiled together with pcsx-redux or can be compiled on it's own. See the corresponding sections in Compiling for instructions. The result of the compilation should be a file called openbios.elf that contains all useful debugging symbols, and a file called openbios.bin which can be used in emulators or even burned to a chip and placed on a retail console. Status This subproject is still under construction, but is fairly functional and usable. OpenBIOS does almost all the same things as the retail BIOS does when booting, and implements most of its features. Many games are booting and working properly with this code. It can be used in emulators or on the real console, either while replacing the rom chip, or by using the \"cart\" build and programming the flash chip of a cheat cart with the result. Organization The BIOS is split in two major parts: the low level code for the bios itself, and the shell, which is the binary that's being loaded into memory at boot time by the bios, to display the SONY sound and logo, and has a small utility menu for playing audio discs, or shuffling around memory cards. While the first part is the main one that's being targeted here, the second one isn't currently present. This may change in the future, but this isn't currently the focus of this project. The original code was most likely chunked into several sub-projects, that were all linked together like a giant patchwork. This approach is less readable, and for this reason, we're not going to do this. However this will result in the ROM/RAM split to be less obvious, and slower at times than the original. Tuning of the hot functions is eventually required. Technicalities The code has been rewritten based off the reverse engineering of a dump of the BIOS of an american SCPH-7001 machine. MD5sum: 1e68c231d0896b7eadcad1d7d8e76129 The ghidra database for it is currently being hosted on a server, alongside a few other pieces of software being reversed. Contact one of the authors if you want access. Commentary The retail PlayStation BIOS code is a constellation of bugs and bad design. The fact that the retail console boots at all is nothing short of a miracle. Half of the provided libc in the A0 table is buggy. The BIOS code is barely able to initialize the CD-Rom, and read the game's binary off of it to boot it; anything beyond that will be crippled with bugs. And this only is viable if you respect a very strict method to create your CD-Rom. The memory card and gamepad code is a steaming-hot heap of human excrement. The provided GPU stubs are inefficient at best. The only sane thing that any software running on the PlayStation ought to do is to immediately disable interrupts, grab the function pointer located at 0x00000310 for FlushCache , in order put it inside a wrapper that disables interrupts before calling it, and then trash the whole memory to install its own code. The only reason FlushCache is required from the retail code is because since the function will unplug the main memory bus off the CPU in order to work, it HAS to run from the 0xbfc memory map, which will still be connected. Anything else from the retail code is virtually useless, and shouldn't be relied upon. Legality Disclaimer: the author is not a lawyer, and the following statement hasn't been reviewed by a professional of the law, so the rest of this document cannot be taken as legal advice. As explained above, this code has been written using disassembly and reverse engineering of a retail bios the author dumped from a second hand console. The same exact methodology was employed by Connectix for their PS1 bios. The conclusion of their lawsuit , and that of Sega v. Accolade seems to indicate that this project here follows and is impacted by the same doctrine.","title":"One"},{"location":"one/#menus","text":"","title":"Menus"},{"location":"one/#pcsx-redux-menus","text":"The menu bar holds some informations : CPU mode Game ID ImGui FPS counter (not psx internal fps)","title":"Pcsx-redux menus"},{"location":"one/#file","text":"Open ISO Close ISO Load Binary Dump save state proto schema Save state slots Load state slots Save global state Load global state Open Lid : Simulate open lid Close Lid : Simulate closed lid Open and Close Lid : Simulate open then closed lid MC1 inserted MC2 inserted Reboot : Restart emulator Quit","title":"File"},{"location":"one/#emulation","text":"Start : Start execution Pause : Pause execution Soft reset : Calls Redux's CPU reset function, which jumps to the BIOS entrypoint (0xBFC00000), resets some COP0 registers and the general purpose registers, and resets some IO. Does not clear vram. Hard reset : Similar to a reboot of the PSX.","title":"Emulation"},{"location":"one/#configuration","text":"Emulation : Emulation settings GPU : graphical processor settings SPU : Sound processor settings UI : Change interface settings Controls : Edit KB/Pad controls Shader presets : Apply a shader preset Configure shaders : show shader editor","title":"Configuration"},{"location":"one/#debug","text":"","title":"Debug"},{"location":"one/#help","text":"Show Imgui demo About","title":"Help"},{"location":"one/#compiling","text":"","title":"Compiling"},{"location":"one/#compiling-pcsx-redux","text":"","title":"Compiling Pcsx-redux"},{"location":"one/#getting-the-sources","text":"The only location for the source is on github . Clone recursively, as the project uses submodules: git clone https://github.com/grumpycoders/pcsx-redux.git --recursive .","title":"Getting the sources"},{"location":"one/#windows","text":"Install Visual Studio 2019 Community Edition . Open the file vsprojects\\pcsx-redux.sln , select pcsx-redux -> pcsx-redux , right click, Set as Startup Project , and hit F7 to build. The project follows the open-and-build paradigm with no extra step, so no specific dependency ought to be needed, as NuGet will take care of downloading them automatically for you on the first build. Note: If you get an error saying hresult e_fail has been returned from a call to a com component , you might need to delete the .suo file in vsproject/vs, restart Visual Studio and retry.","title":"Windows"},{"location":"one/#openbios","text":"Using Visual Studio Code , one can use the task \"make_openbios\" to compile: CTRL-P then task make_openbios to compile.","title":"Openbios"},{"location":"one/#linux","text":"","title":"Linux"},{"location":"one/#compiling-with-docker","text":"Run ./dockermake.sh . You need docker for this to work. 1 2 3 4 # Debian derivative; Ubuntu, Mint... sudo apt install docker # Arch derivative; Manjaro... sudo pacman -S docker You will also need a few libraries on your system for this to work. Check the Dockerfile for a list of library packages to install.","title":"Compiling with Docker"},{"location":"one/#compiling-with-make","text":"Debian derivatives ( for full emulator compilation ): 1 sudo apt-get install -y build-essential git make pkg-config clang g++ g++-mipsel-linux-gnu cpp-mipsel-linux-gnu binutils-mipsel-linux-gnu libfreetype-dev libavcodec-dev libavformat-dev libavutil-dev libglfw3-dev libswresample-dev libuv1-dev zlib1g-dev Arch derivatives : 1 sudo pacman -S clang git make pkg-config ffmpeg libuv zlib glfw-x11 curl xorg-server-xvfb You can then just enter the 'pcsx-redux' directory and compile without using docker with make . If you have a different mips compiler, you'll need to override some variables, such as PREFIX=mipsel-none-elf FORMAT=elf32-littlemips .","title":"Compiling with make"},{"location":"one/#openbios_1","text":"Building OpenBIOS on Linux can be done with docker : ./dockermake.sh openbios , or using make , with the g++-mipsel-linux-gnu package installed ; make openbios .","title":"Openbios"},{"location":"one/#macos","text":"You need MacOS Catalina with the latest XCode to build, as well as a few homebrew packages. Run the brew installation script to get all the necessary dependencies. Run make to build. Compiling OpenBIOS will require a mips compiler, that you can generate using the following commands:","title":"MacOS"},{"location":"one/#openbios_2","text":"1 2 brew install ./tools/macos-mips/mipsel-none-elf-binutils.rb brew install ./tools/macos-mips/mipsel-none-elf-gcc.rb Then, you can compile OpenBIOS using make -C ./src/mips/openbios .","title":"Openbios"},{"location":"one/#compiling-psx-code","text":"If you're only interested in compiling psx code, you can clone the pcsx-redux repo; 1 git clone https://github.com/grumpycoders/pcsx-redux.git --recursive then install a mips toolchain and get the converted PsyQ libraries in the pcsx-redux/src/mips/psyq/ folder as per these instructions . You can also find the pre-compiled converted Psyq libraries online .","title":"Compiling PSX code"},{"location":"one/#getting-the-toolchain-on-windows","text":"Download the MIPS toolchain here : https://static.grumpycoder.net/pixel/mips/g++-mipsel-none-elf-10.3.0.zip and add the bin folder to your $PATH . You can test it's working by launching a command prompt and typing mipsel-none-elf-gcc.exe --version . If you get a message like mipsel-none-gnu-gcc (GCC) 10.3.0 , then it's working !","title":"Getting the toolchain on Windows"},{"location":"one/#getting-the-toolchain-on-gnulinux","text":"","title":"Getting the toolchain on GNU/Linux"},{"location":"one/#debian-derivative-ubuntu-mint","text":"1 sudo apt install g++-mipsel-linux-gnu cpp-mipsel-linux-gnu binutils-mipsel-linux-gnu","title":"Debian derivative; Ubuntu, Mint..."},{"location":"one/#arch-derivative-manjaro","text":"The mipsel environment can be installed from AUR : cross-mipsel-linux-gnu-binutils and cross-mipsel-linux-gnu-gcc using your AURhelper of choice: 1 trizen -S cross-mipsel-linux-gnu-binutils cross-mipsel-linux-gnu-gcc","title":"Arch derivative; Manjaro..."},{"location":"one/#cli-flags","text":"","title":"Cli &amp; flags"},{"location":"one/#command-line-flags","text":"You can launch pcsx-redux with the following command line parameters: The parsing code doesn't care about the number of dashes in the parameter's flag, so '-' can be used as well as '--', or any number of dashes. Flag Meaning -run Begin execution on startup. -stdout Redirect log output to stdout. -logfile Specify a file to log output to. -bios Specify a BIOS file. -testmode Interpret internal API 's pcsx_exit() command and close the emulator. -loadexe Load a PSX exe. -iso Load a PSX disk image (iso, bin/cue). -memcard1 Specify a memory card file to use as memory card slot 1. -memcard2 Specify a memory card file to use as memory card slot 2. -pcdrv Enable the pcdrv: device interface. (Access PC filesystem through SIO) -pcdrvbase Specify base directory for pcdrv","title":"Command Line Flags"},{"location":"one/#gdb-server","text":"","title":"Gdb-server"},{"location":"one/#gdb-server_1","text":"The GDB server allows you to set breakpoints and control your PSX program's execution from your gdb compatible IDE.","title":"GDB server"},{"location":"one/#enabling-the-gdb-server","text":"In pcsx-redux: Configuration > Emulation > Enable GDB server . Make sure the debugger is also enabled.","title":"Enabling the GDB server"},{"location":"one/#gdb-setup","text":"You need gdb-multiarch on your system :","title":"GDB setup"},{"location":"one/#windows_1","text":"Download a pre-compiled version from here : https://static.grumpycoder.net/pixel/gdb-multiarch-windows/","title":"Windows"},{"location":"one/#gnulinux","text":"Install via your package manager : 1 2 3 4 5 # Debian derivative; Ubuntu, Mint... sudo apt install gdb-multiarch # Arch derivative; Manjaro # 'gdb-multiarch' is available in aur : https://aur.archlinux.org/packages/gdb-multiarch/ sudo trizen -S gdb-multiarch","title":"GNU/Linux"},{"location":"one/#ide-setup","text":"","title":"IDE setup"},{"location":"one/#ms-vscode","text":"Install the Native debug extension : https://marketplace.visualstudio.com/items?itemName=webfreak.debug Adapt your launch.json file to your environment : A sample lanuch.json file is available here . This should go in your-project/.vscode/ . You need to adapt the values of \"target\" , \"gdbpath\" and \"autorun\" according to your system :","title":"MS VScode"},{"location":"one/#target","text":"This is the path to your .elf executable : 1 \"target\" : \"HelloWorld.elf\" , https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L9","title":"target"},{"location":"one/#gdbpath","text":"This the path to the gdb-multiarch executable: 1 \"gdbpath\" : \"/usr/bin/gdb-multiarch\" , https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L10","title":"gdbpath"},{"location":"one/#autorun","text":"1 2 3 4 \"autorun\" : [ \"target remote localhost:3333\" , [ ... ] \"load HelloWorld.elf\" , Make sure that \"load your-file.elf\" corresponds to the \"target\" value. https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L15 By default, using localhost should work, but if encountering trouble, try using your computer's local IP (e.g; 192.168.x.x, 10.0.x.x, etc.) https://github.com/NDR008/VSCodePSX/blob/d70658b5ad420685367de4f3c18b89d72535631e/get_started/.vscode/launch.json#L13","title":"autorun"},{"location":"one/#geany","text":"Make sure you installed the official plugins and enable the Scope debugger . To enable the plugin, open Geany, go to Tools > Plugin manager and enable Scope Debugger . You can find the debugging facilities in the Debug menu ; You can find the plugin's documentation here : https://plugins.geany.org/scope.html","title":"Geany"},{"location":"one/#gdbinit","text":"Create a .gdbinit file at the root of your project with the following content, adapting the path to your elf file and the gdb server's ip. 1 2 3 4 target remote localhost:3333 symbol-file load /path/to/your/executable.elf monitor reset shellhalt load /path/to/your/executable.elf","title":".gdbinit"},{"location":"one/#plugin-configuration","text":"In Geany : Debug > Setup Program :","title":"Plugin configuration"},{"location":"one/#beginning-debugging","text":"Launch pcsx-redux , then run the debugger from your IDE. It should load the elf file, and execute until the next breakpoint.","title":"Beginning Debugging"},{"location":"one/#starting-debugging-in-geany","text":"Your browser does not support the video tag. Source : https://archive.org/details/pcsx_redux_geany_gdb","title":"Starting debugging in Geany"},{"location":"one/#additional-tools","text":"https://github.com/cyrus-and/gdb-dashboard/","title":"Additional tools"},{"location":"one/#mips-api","text":"","title":"Mips &amp; api"},{"location":"one/#mips-api_1","text":"","title":"Mips API"},{"location":"one/#description","text":"Pcsx-redux has a special API that mips binaries can use : 1 2 3 4 5 6 static __inline__ void pcsx_putc ( int c ) { * (( volatile char * const ) 0x1f802080 ) = c ; } static __inline__ void pcsx_debugbreak () { * (( volatile char * const ) 0x1f802081 ) = 0 ; } static __inline__ void pcsx_exit ( int code ) { * (( volatile int16_t * const ) 0x1f802082 ) = code ; } static __inline__ void pcsx_message ( const char * msg ) { * (( volatile char * const ) 0x1f802084 ) = msg ; } static __inline__ int pcsx_present () { return * (( volatile uint32_t * const ) 0x1f802080 ) == 0x58534350 ; } Source : https://github.com/grumpycoders/pcsx-redux/blob/main/src/mips/common/hardware/pcsxhw.h#L31-L36 The API needs DEV8/EXP2 (1f802000 to 1f80207f), which holds the hardware register for the bios POST status, to be expanded to 1f8020ff. Thus the need to use a custom crt0.s if you plan on running your code on real hardware. The default file provided with the Nugget+PsyQ development environment does that: 1 2 3 4 5 6 7 8 9 10 11 _start: lw $ t2 , SBUS_DEV8_CTRL lui $ t0 , 8 lui $ t1 , 1 _check_dev8: bge $ t2 , $ t0 , _store_dev8 nop b _check_dev8 add $ t2 , $ t1 _store_dev8: sw $ t2 , SBUS_DEV8_CTRL Source : https://github.com/grumpycoders/pcsx-redux/blob/main/src/mips/common/crt0/crt0.s#L36-L46","title":"Description"},{"location":"one/#functions","text":"The following functions are available : Function Usage pcsx_putc(int c) Print ASCII character with code c to console/stdout. pcsx_debugbreak() Break execution ( Pause emulation ). pcsx_exit(int code) Exit emulator and forward code as exit code. pcsx_message(const char* msg) Create a UI dialog displaying msg pcsx_present() Returns 1 if code is running in pcsx-redux Example of a UI dialog created with pcsx_message() :","title":"Functions"},{"location":"one/#cpu-trace-dump","text":"","title":"Cpu, trace &amp; dump"},{"location":"one/#dumping-a-cpu-trace-to-a-file","text":"","title":"Dumping a CPU trace to a file"},{"location":"one/#setup","text":"In pcsx-redux, make sure Debug > Show logs is enabled. In the 'Logs' window, hide all logs : Displayed > Hide all To avoid unnecessary noise, you can also skip ISR during CPU traces : Special > Skip ISR during CPU traces","title":"Setup"},{"location":"one/#begin-dump","text":"To dump the CPU traces, launch pcsx-redux with the following command : 1 2 3 pcsx-redux -stdout -logfile log.txt # Alternatively, you can use -stdout on its own and pipe the output to a file. pcsx-redux -stdout >> log.txt You can use additional flags to launch an executable/disk image in one go, e.g : 1 pcsx-redux -stdout -logfile tst.log -iso image.cue -run","title":"Begin dump"},{"location":"one/#source","text":"https://discord.com/channels/642647820683444236/663664210525290507/882608398993063997","title":"Source"},{"location":"one/#web-server","text":"","title":"Web &amp; server"},{"location":"one/#web-server_1","text":"A web server can be activated. This allows the use of a REST api to access various features.","title":"Web server"},{"location":"one/#activation","text":"You can activate the web server by going to Configuration > Emulation > Enable Web Server","title":"Activation"},{"location":"one/#rest-api","text":"By default, the server listens for incoming connection on localhost:8080 . URL Function http://localhost:8080/api/v1/gpu/vram/raw Dump VRAM http://localhost:8080/api/v1/cpu/ram/raw Dump RAM","title":"REST API"},{"location":"one/#openbios_3","text":"","title":"Openbios"},{"location":"one/#openbios_4","text":"Openbios is, as it's name imply, an open-source alternative to a retail PSX bios that can be non-trivial to dump.","title":"Openbios"},{"location":"one/#purposes-of-openbios","text":"Educational Ease of distribution Automated testing See this page for more details.","title":"Purposes of Openbios"},{"location":"one/#building","text":"It is compiled together with pcsx-redux or can be compiled on it's own. See the corresponding sections in Compiling for instructions. The result of the compilation should be a file called openbios.elf that contains all useful debugging symbols, and a file called openbios.bin which can be used in emulators or even burned to a chip and placed on a retail console.","title":"Building"},{"location":"one/#status","text":"This subproject is still under construction, but is fairly functional and usable. OpenBIOS does almost all the same things as the retail BIOS does when booting, and implements most of its features. Many games are booting and working properly with this code. It can be used in emulators or on the real console, either while replacing the rom chip, or by using the \"cart\" build and programming the flash chip of a cheat cart with the result.","title":"Status"},{"location":"one/#organization","text":"The BIOS is split in two major parts: the low level code for the bios itself, and the shell, which is the binary that's being loaded into memory at boot time by the bios, to display the SONY sound and logo, and has a small utility menu for playing audio discs, or shuffling around memory cards. While the first part is the main one that's being targeted here, the second one isn't currently present. This may change in the future, but this isn't currently the focus of this project. The original code was most likely chunked into several sub-projects, that were all linked together like a giant patchwork. This approach is less readable, and for this reason, we're not going to do this. However this will result in the ROM/RAM split to be less obvious, and slower at times than the original. Tuning of the hot functions is eventually required.","title":"Organization"},{"location":"one/#technicalities","text":"The code has been rewritten based off the reverse engineering of a dump of the BIOS of an american SCPH-7001 machine. MD5sum: 1e68c231d0896b7eadcad1d7d8e76129 The ghidra database for it is currently being hosted on a server, alongside a few other pieces of software being reversed. Contact one of the authors if you want access.","title":"Technicalities"},{"location":"one/#commentary","text":"The retail PlayStation BIOS code is a constellation of bugs and bad design. The fact that the retail console boots at all is nothing short of a miracle. Half of the provided libc in the A0 table is buggy. The BIOS code is barely able to initialize the CD-Rom, and read the game's binary off of it to boot it; anything beyond that will be crippled with bugs. And this only is viable if you respect a very strict method to create your CD-Rom. The memory card and gamepad code is a steaming-hot heap of human excrement. The provided GPU stubs are inefficient at best. The only sane thing that any software running on the PlayStation ought to do is to immediately disable interrupts, grab the function pointer located at 0x00000310 for FlushCache , in order put it inside a wrapper that disables interrupts before calling it, and then trash the whole memory to install its own code. The only reason FlushCache is required from the retail code is because since the function will unplug the main memory bus off the CPU in order to work, it HAS to run from the 0xbfc memory map, which will still be connected. Anything else from the retail code is virtually useless, and shouldn't be relied upon.","title":"Commentary"},{"location":"one/#legality","text":"Disclaimer: the author is not a lawyer, and the following statement hasn't been reviewed by a professional of the law, so the rest of this document cannot be taken as legal advice. As explained above, this code has been written using disassembly and reverse engineering of a retail bios the author dumped from a second hand console. The same exact methodology was employed by Connectix for their PS1 bios. The conclusion of their lawsuit , and that of Sega v. Accolade seems to indicate that this project here follows and is impacted by the same doctrine.","title":"Legality"},{"location":"openbios/","text":"Openbios Openbios is, as it's name imply, an open-source alternative to a retail PSX bios that can be non-trivial to dump. Purposes of Openbios Educational Ease of distribution Automated testing See this page for more details. Building It is compiled together with pcsx-redux or can be compiled on it's own. See the corresponding sections in Compiling for instructions. The result of the compilation should be a file called openbios.elf that contains all useful debugging symbols, and a file called openbios.bin which can be used in emulators or even burned to a chip and placed on a retail console. Status This subproject is still under construction, but is fairly functional and usable. OpenBIOS does almost all the same things as the retail BIOS does when booting, and implements most of its features. Many games are booting and working properly with this code. It can be used in emulators or on the real console, either while replacing the rom chip, or by using the \"cart\" build and programming the flash chip of a cheat cart with the result. Organization The BIOS is split in two major parts: the low level code for the bios itself, and the shell, which is the binary that's being loaded into memory at boot time by the bios, to display the SONY sound and logo, and has a small utility menu for playing audio discs, or shuffling around memory cards. While the first part is the main one that's being targeted here, the second one isn't currently present. This may change in the future, but this isn't currently the focus of this project. The original code was most likely chunked into several sub-projects, that were all linked together like a giant patchwork. This approach is less readable, and for this reason, we're not going to do this. However this will result in the ROM/RAM split to be less obvious, and slower at times than the original. Tuning of the hot functions is eventually required. Technicalities The code has been rewritten based off the reverse engineering of a dump of the BIOS of an american SCPH-7001 machine. MD5sum: 1e68c231d0896b7eadcad1d7d8e76129 The ghidra database for it is currently being hosted on a server, alongside a few other pieces of software being reversed. Contact one of the authors if you want access. Commentary The retail PlayStation BIOS code is a constellation of bugs and bad design. The fact that the retail console boots at all is nothing short of a miracle. Half of the provided libc in the A0 table is buggy. The BIOS code is barely able to initialize the CD-Rom, and read the game's binary off of it to boot it; anything beyond that will be crippled with bugs. And this only is viable if you respect a very strict method to create your CD-Rom. The memory card and gamepad code is a steaming-hot heap of human excrement. The provided GPU stubs are inefficient at best. The only sane thing that any software running on the PlayStation ought to do is to immediately disable interrupts, grab the function pointer located at 0x00000310 for FlushCache , in order put it inside a wrapper that disables interrupts before calling it, and then trash the whole memory to install its own code. The only reason FlushCache is required from the retail code is because since the function will unplug the main memory bus off the CPU in order to work, it HAS to run from the 0xbfc memory map, which will still be connected. Anything else from the retail code is virtually useless, and shouldn't be relied upon. Legality Disclaimer: the author is not a lawyer, and the following statement hasn't been reviewed by a professional of the law, so the rest of this document cannot be taken as legal advice. As explained above, this code has been written using disassembly and reverse engineering of a retail bios the author dumped from a second hand console. The same exact methodology was employed by Connectix for their PS1 bios. The conclusion of their lawsuit , and that of Sega v. Accolade seems to indicate that this project here follows and is impacted by the same doctrine.","title":"Openbios"},{"location":"openbios/#openbios","text":"Openbios is, as it's name imply, an open-source alternative to a retail PSX bios that can be non-trivial to dump.","title":"Openbios"},{"location":"openbios/#purposes-of-openbios","text":"Educational Ease of distribution Automated testing See this page for more details.","title":"Purposes of Openbios"},{"location":"openbios/#building","text":"It is compiled together with pcsx-redux or can be compiled on it's own. See the corresponding sections in Compiling for instructions. The result of the compilation should be a file called openbios.elf that contains all useful debugging symbols, and a file called openbios.bin which can be used in emulators or even burned to a chip and placed on a retail console.","title":"Building"},{"location":"openbios/#status","text":"This subproject is still under construction, but is fairly functional and usable. OpenBIOS does almost all the same things as the retail BIOS does when booting, and implements most of its features. Many games are booting and working properly with this code. It can be used in emulators or on the real console, either while replacing the rom chip, or by using the \"cart\" build and programming the flash chip of a cheat cart with the result.","title":"Status"},{"location":"openbios/#organization","text":"The BIOS is split in two major parts: the low level code for the bios itself, and the shell, which is the binary that's being loaded into memory at boot time by the bios, to display the SONY sound and logo, and has a small utility menu for playing audio discs, or shuffling around memory cards. While the first part is the main one that's being targeted here, the second one isn't currently present. This may change in the future, but this isn't currently the focus of this project. The original code was most likely chunked into several sub-projects, that were all linked together like a giant patchwork. This approach is less readable, and for this reason, we're not going to do this. However this will result in the ROM/RAM split to be less obvious, and slower at times than the original. Tuning of the hot functions is eventually required.","title":"Organization"},{"location":"openbios/#technicalities","text":"The code has been rewritten based off the reverse engineering of a dump of the BIOS of an american SCPH-7001 machine. MD5sum: 1e68c231d0896b7eadcad1d7d8e76129 The ghidra database for it is currently being hosted on a server, alongside a few other pieces of software being reversed. Contact one of the authors if you want access.","title":"Technicalities"},{"location":"openbios/#commentary","text":"The retail PlayStation BIOS code is a constellation of bugs and bad design. The fact that the retail console boots at all is nothing short of a miracle. Half of the provided libc in the A0 table is buggy. The BIOS code is barely able to initialize the CD-Rom, and read the game's binary off of it to boot it; anything beyond that will be crippled with bugs. And this only is viable if you respect a very strict method to create your CD-Rom. The memory card and gamepad code is a steaming-hot heap of human excrement. The provided GPU stubs are inefficient at best. The only sane thing that any software running on the PlayStation ought to do is to immediately disable interrupts, grab the function pointer located at 0x00000310 for FlushCache , in order put it inside a wrapper that disables interrupts before calling it, and then trash the whole memory to install its own code. The only reason FlushCache is required from the retail code is because since the function will unplug the main memory bus off the CPU in order to work, it HAS to run from the 0xbfc memory map, which will still be connected. Anything else from the retail code is virtually useless, and shouldn't be relied upon.","title":"Commentary"},{"location":"openbios/#legality","text":"Disclaimer: the author is not a lawyer, and the following statement hasn't been reviewed by a professional of the law, so the rest of this document cannot be taken as legal advice. As explained above, this code has been written using disassembly and reverse engineering of a retail bios the author dumped from a second hand console. The same exact methodology was employed by Connectix for their PS1 bios. The conclusion of their lawsuit , and that of Sega v. Accolade seems to indicate that this project here follows and is impacted by the same doctrine.","title":"Legality"},{"location":"web_server/","text":"Web server A web server can be activated. This allows the use of a REST api to access various features. Activation You can activate the web server by going to Configuration > Emulation > Enable Web Server REST API By default, the server listens for incoming connection on localhost:8080 . URL Function http://localhost:8080/api/v1/gpu/vram/raw Dump VRAM http://localhost:8080/api/v1/cpu/ram/raw Dump RAM","title":"Web server"},{"location":"web_server/#web-server","text":"A web server can be activated. This allows the use of a REST api to access various features.","title":"Web server"},{"location":"web_server/#activation","text":"You can activate the web server by going to Configuration > Emulation > Enable Web Server","title":"Activation"},{"location":"web_server/#rest-api","text":"By default, the server listens for incoming connection on localhost:8080 . URL Function http://localhost:8080/api/v1/gpu/vram/raw Dump VRAM http://localhost:8080/api/v1/cpu/ram/raw Dump RAM","title":"REST API"}]}